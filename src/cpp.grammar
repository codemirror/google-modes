extends "./c.grammar"

skip whitespace {
  context Statement {
    Class |
    namespace declName? (op("=") variableName ";" | Block) |
    throw Expression ";" |
    try Block (catch "(" Type declName? ")" Block)* |
    asm "{" string "}" |
    using (typename Type | namespace? variableName) ";" |
    TemplateHead Statement |
    &constructorAhead declName FunctionDef |
    nameQualifier+ (MaybeType DeclRest | qualifiedVariableName ExpressionSuffix* ";") |
    super
  }

  TypeSuffix {
    TemplateArgs |
    "::" Type |
    super
  }

  BaseExpression {
    this |
    Lambda |
    cast "<" Type ">" "(" Expression ")" |
    super
  }

  Lambda {
    "[" ListOf("&" variableName? | "=" | this) "]" FunctionDef
  }

  context FunctionDef {
    ParamList
    qualifier*
    ("&" | "&&")?
    (noexcept ("(" Expression ")")? | throw "(" ListOf(Type) ")")?
    ("->" Type)?
    InitializerList?
    (";" | Block)
  }

  context TemplateHead {
    export? template TemplateParams whitespace
  }

  context InitializerList { (":" ListOf(CtorInitializer)) }

  CtorInitializer { fieldName ("(" ListOf(Expression) ")" | "{" ListOf(Expression) "}") }

  ExpressionPrefix {
    delete | new ("(" Expression ")")? | super
  }

  Type {
    typename Type | super
  }

  TemplateParams {
    "<" ListOf(TypeParam | modifier* declName Initializer?) ">"
  }

  context TemplateArgs {
    "<" ListOf(TypeParam | modifier* Type Initializer?) ">"
  }

  TypeParam {
     (template TemplateArgs)? (class | typename) declName (op("=") variableName)?
  }

  Class {
    (class | structUnion) (alignas "(" number ")")? declName (":" virtual? access? Type)? ClassBody
  }

  context ClassBody {
    "{" (access ":" | ObjectMember)* "}"
  }

  context ObjectMember {
    friend* (modifier | qualifier)*
    (ctorDtorName | Type declName)
    (Initializer? ";" | FunctionDef)
  }

  Initializer { super | BlockOf(Expression, ",") }
}

tokens {
  namespace { kw("namespace") }

  typename { kw("typename") }

  new { kw("new") }
  delete { kw("delete") }
  this { kw("this") }
  try { kw("try") }
  catch { kw("catch") }
  throw { kw("throw") }
  noexcept { kw("noexcept") }
  asm { kw("asm") }
  export { kw("export") }
  template { kw("template") }
  class { kw("class") }
  virtual { kw("virtual") }
  access { kw("private" | "public" | "protected") }
  friend { kw("friend") }
  operator { kw("operator") }
  using { kw("using") }
  alignas { kw("alignas") }
  cast { kw(("dynamic" | "static" | "const" | "reinterpret") "_cast") }

  variableName { nameQualifier+ qualifiedVariableName | (unqualifiedCallee | unqualifiedVariableName) }

  modifier { kw("inline" | "virtual" | "explicit") | super }

  prefixOp="operator" {
    typename | super
  }

  number="number" {
    ("0x" (digit | "a"-"f" | "A"-"F" | "'")+ |
     "0b" ("0" | "1" | "'")+ |
     (digit digits ("." digits)? | "." digit digits) (("e" | "E") "-"? digits)?)
    ("L" | "l" | "U" | "u" | "F" | "f")?
  }
}

digits { (digit | "'")* }

nameQualifier="meta" { "::" | identifier " "* "::" }

declName { operator (binOp | prefixOp) | nameQualifier* unqualifiedDeclName }

unqualifiedDeclName="def" { "~"? identifier }

unqualifiedCallee="variable callee" { identifier ~"(" }

unqualifiedVariableName="variable" { "~"? identifier }

qualifiedVariableName="qualified" { unqualifiedVariableName }

typeNameInner { nameQualifier* unqualifiedTypeName }

unqualifiedTypeName="type" { identifier }

maybeTypeName {
  !(("new" | "delete") !identifierChar) unqualifiedTypeName ~(!identifierChar whitespace TypeSuffix* whitespace identifierStart)
}

ctorDtorName="def" { "~"? identifier ~(" "* "(") }
